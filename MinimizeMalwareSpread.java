//Color each connected component of the graph using DFS to label them uniquely
//Next, we ccount nodes and infected nodes for each component
//We loop through the infected nodes and check if they are the only infected node in the 
//large group or else we return the minimum infected node

//Time Complexity:O(V^2)
//Space Complexity:O(V)
public class MinimizeMalwareSpread {
    int[] colors;
    int n;
    public int minMalwareSpread(int[][] graph,int[] initial)
    {
        this.n = graph.length;
        this.colors = new int[n];
        Arrays.fill(colors,-1);
        int cl = 0;

        for(int i=0;i<n;i++)
        {
            dfs(graph,i,cl);
            cl++;
        }

        int[] groups = new int[cl];
        for(int node: colors)
        {
            groups[node]++;
        }

        int[] infctd = new int[cl];
        for(int node: initial){
            infctd[colors[node]]++;
        }

        int result = Integer.MAX_VALUE;

        for(int node: initial)
        {
            if(infctd[colors[node]] ==1)
            {
                if(result==Integer.MAX_VALUE)
                {
                    result = node;
                }
                else if(groups[colors[node]]>groups[colors[result]])
                {
                    result = node;
                }
                else if(groups[colors[node]] == groups[colors[result]])
                {
                    result = Math.min(result,node);
                }
            }
        }

        if(result==Integer.MAX_VALUE)
        {
            for(int node:initial)
            {
                result = Math.min(result, node);
            }
        }
        return result;
    }

    private void dfs(int[][] graph, int i, int cl)
    {
        if(colors[i] != -1) return;

        colors[i] = cl;
        for(int j=0;j<n;j++)
        {
            if(i==j) continue;
            if(graph[i][j] == 1){
                dfs(graph,j,cl);
            }
        }
    }
}
